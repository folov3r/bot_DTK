import asyncio
import logging
import os
from datetime import date, timedelta
import yadisk
from aiogram import Bot, Dispatcher, types
from aiogram.types import FSInputFile, ReplyKeyboardMarkup, ReplyKeyboardRemove
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from docx import Document
from dotenv import load_dotenv
from cache_schedule import schedule_cache
from db_def import *

load_dotenv()

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN_TEST")
YANDEX_TOKEN = os.getenv("YANDEX_TOKEN")

bot = Bot(token=TELEGRAM_TOKEN)
dp = Dispatcher()

yadisk_client = yadisk.Client(token=YANDEX_TOKEN)



def check_and_notify(file_name, update: bool = False):
    with sqlite3.connect("db/notifications.db") as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT notified FROM notifications WHERE file_name = ?", (file_name,))
        result = cursor.fetchone()
        users = get_all_users_id()
        splited_name = file_name.split(".docx")[0]
        for user_id in users:
            if not result or not result[0] and update == False:
                asyncio.create_task(send_notification(user_id, f"üì• {splited_name} –∑–∞–≥—Ä—É–∂–µ–Ω–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä."))
                cursor.execute("""
                INSERT OR REPLACE INTO notifications (file_name, notified)
                VALUES (?, ?)
            """, (file_name, True))
                conn.commit()
            elif result and update == True:
                asyncio.create_task(send_notification(user_id, f"‚ö†Ô∏èüì• {splited_name} –∏–∑–º–µ–Ω–∏–ª–æ—Å—å –∏ –±—ã–ª–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä."))


allowed_groups = [
    "10", "11.1", "11.2", "12", "13", "14", "15", "16", "17", "18", "19",
    "–ö–°–ö-1", "–û–ü-1", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
    "–ö–°–ö-2", "–û–ü-2", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
    "–ö–°–ö-3", "–û–ü-3", "40.1", "40.2", "41", "42", "43", "44", "45", "101", "102", "201", "202", "203"
]


def validate_and_correct_group(user_input):
    user_input = user_input.upper()

    if user_input in allowed_groups:
        return user_input, True

    for group in allowed_groups:
        if user_input.replace(" ", "-") == group or user_input == group.replace("-", " "):
            return group, True

    if user_input.isdigit():
        for group in allowed_groups:
            if group.isdigit() and group == user_input:
                return group, True

    return None, False


def create_keyboard(buttons):
    return types.ReplyKeyboardMarkup(
        keyboard=[[types.KeyboardButton(text=btn) for btn in row] for row in buttons],
        resize_keyboard=True
    )


main_keyboard = create_keyboard([
    ["–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ", "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤"],
    ["–ü—Ä–æ—Ñ–∏–ª—å"]
])

schedule_keyboard = create_keyboard([
    ["–°–µ–≥–æ–¥–Ω—è", "–ó–∞–≤—Ç—Ä–∞"],
    ["–ü–æ—Å–ª–µ –∑–∞–≤—Ç—Ä–∞", "–î—Ä—É–≥–∞—è –¥–∞—Ç–∞"],
    ["–î—Ä—É–≥–∞—è –≥—Ä—É–ø–ø–∞"],
    ["–û—Ç–º–µ–Ω–∞"]
])

schedule_keyboard_another_group = create_keyboard([
    ["–°–µ–≥–æ–¥–Ω—è", "–ó–∞–≤—Ç—Ä–∞"],
    ["–ü–æ—Å–ª–µ –∑–∞–≤—Ç—Ä–∞", "–î—Ä—É–≥–∞—è –¥–∞—Ç–∞"],
    ["–í–µ—Ä–Ω—É—Ç—å—Å—è"]
])

cancel_keyboard = create_keyboard([["–û—Ç–º–µ–Ω–∞"]])

return_keyboard = create_keyboard([["–í–µ—Ä–Ω—É—Ç—å—Å—è"]])

profile_keyboard = create_keyboard([
    ["–ò–∑–º–µ–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ", "–£–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç"],
    ["–ê–≤—Ç–æ —Ä–∞—Å—Å—ã–ª–∫–∞", "–ò–∑–±—Ä–∞–Ω–Ω—ã–µ –≥—Ä—É–ø–ø—ã"],  # –ù–æ–≤–∞—è –∫–Ω–æ–ø–∫–∞
    ["–û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å"],
    ["–í–µ—Ä–Ω—É—Ç—å—Å—è"]
])

login_lvl_1_keyboard = create_keyboard([["/login"]])

yes_no_keyboard = create_keyboard([["–î–∞", "–ù–µ—Ç"]])

back_feedback_keyboard = create_keyboard([["–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é"]])

choose_list_users = create_keyboard([["–°—Ç—É–¥–µ–Ω—Ç–æ–≤",'–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π']])

def create_favorite_groups_keyboard(user_id: int):
    favorite_groups = get_favorite_groups(user_id)
    buttons = [[InlineKeyboardButton(text=group, callback_data=f"remove_favorite_{group}")] for group in favorite_groups]
    buttons.append([InlineKeyboardButton(text="–î–æ–±–∞–≤–∏—Ç—å –≥—Ä—É–ø–ø—É", callback_data="add_favorite_group")])
    buttons.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_profile")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def process_schedule_file(file_path):
    target_date = file_path.split("/")[-1]

    if target_date in schedule_cache:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –∫–µ—à–∞
        current_hash = get_file_hash(file_path)
        cached_hash = schedule_cache[target_date].get("hash") if isinstance(schedule_cache[target_date], dict) else None
        if cached_hash == current_hash:
            logging.info(f"–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–µ—à –¥–ª—è –¥–∞—Ç—ã {target_date}")
            return schedule_cache[target_date]
        else:
            logging.info("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å, –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–µ—à–∞")

    schedule_data = {}
    teacher_schedule_data = {}
    doc = Document(file_path)
    current_group = None

    def add_schedule_entry(group, pair_number, subject, teacher, room):
        if group not in schedule_data:
            schedule_data[group] = []

        if teacher and teacher not in teacher_schedule_data:
            teacher_schedule_data[teacher] = {}

        if subject in ["–ü—Ä–∞–∫—Ç–∏–∫–∞", "–†–∞–∑–≥–æ–≤–æ—Ä—ã –æ –≤–∞–∂–Ω–æ–º", "–°–µ—Å—Å–∏—è"]:
            schedule_entry = f"|{pair_number} {subject}|"
        elif subject or teacher or room:
            schedule_entry = f"|{pair_number} {subject}| |{teacher}| |{room}|"
        else:
            schedule_entry = f"|{pair_number} –ù–µ—Ç –ø–∞—Ä—ã|"

        schedule_data[group].append((pair_number, schedule_entry))

        if teacher:
            if group not in teacher_schedule_data[teacher]:
                teacher_schedule_data[teacher][group] = []
            teacher_entry = f"|{pair_number} {subject}| |{room}|"
            teacher_schedule_data[teacher][group].append((pair_number, teacher_entry))

    try:
        for table in doc.tables:
            rows = list(table.rows)
            for i, row in enumerate(rows):
                cells = [cell.text.strip() if cell.text else "" for cell in row.cells]
                if len(cells) >= 3:
                    if cells[0]:
                        current_group = cells[0]
                    elif not cells[0] and not cells[1] and not cells[2] and not cells[3] and not cells[4]:
                        current_group = None
                        continue

                    if current_group:
                        teacher = cells[3] if len(cells) > 3 else None
                        room = cells[4] if len(cells) > 4 else None
                        add_schedule_entry(current_group, cells[1], cells[2], teacher, room)

        for group in schedule_data:
            pairs = schedule_data[group]
            last_filled_index = -1
            for i, (pair_number, entry) in enumerate(pairs):
                if not entry.endswith("–ù–µ—Ç –ø–∞—Ä—ã|"):
                    last_filled_index = i

            if last_filled_index != -1:
                schedule_data[group] = pairs[:last_filled_index + 1]

        for group in schedule_data:
            schedule_data[group] = "\n".join([entry[1] for entry in schedule_data[group]])

        for teacher in teacher_schedule_data:
            for group in teacher_schedule_data[teacher]:
                teacher_schedule_data[teacher][group].sort(
                    key=lambda x: int(x[0].split('.')[0]) if x[0].split('.')[0].isdigit() else 0)
                teacher_schedule_data[teacher][group] = "\n".join(
                    [entry[1] for entry in teacher_schedule_data[teacher][group]])

        schedule_cache[target_date] = (schedule_data, teacher_schedule_data)
        logging.info(f"–î–∞–Ω–Ω—ã–µ –¥–ª—è –¥–∞—Ç—ã {target_date} –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –∫–µ—à")

        result = {
            "data": (schedule_data, teacher_schedule_data),
            "hash": get_file_hash(file_path)
        }

        schedule_cache[target_date] = result
        logging.info(f"–î–∞–Ω–Ω—ã–µ –¥–ª—è –¥–∞—Ç—ã {target_date} –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –∫–µ—à–µ")

        return schedule_data, teacher_schedule_data

    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞: {e}")
        return None, None


def save_user_data(user_id, username, value, is_teacher=0):
    db_execute("users", """
        INSERT OR REPLACE INTO users (user_id, username, value, is_teacher)
        VALUES (?, ?, ?, ?)
    """, (user_id, username, value, is_teacher))


def get_user_data(user_id):
    result = db_fetch("users", "SELECT value, is_teacher, notifications_enabled FROM users WHERE user_id = ?",(user_id,))
    return result[0] if result else (None, None, None)

async def save_list_users(message: types.Message, users: list):
    with open("users_list.txt", "w", encoding="utf-8-sig") as file:
        count_users = len(users)
        students = [user for user in users if user[3] == 0]
        teachers = [user for user in users if user[3] == 1]
        students_list = "\n".join(
            f"|üÜî: {user_id}| |üë§: https://t.me/{username}| |–ì—Ä—É–ø–ø–∞: {value}| |üîî: {notify}|"
            for user_id, username, value, _, notify in students
            )
        teachers_list = "\n".join(f"|üÜî: {user_id}| |üë§: https://t.me/{username}| |–§–ò–û: {value}| |üîî: {notify}|"
            for user_id, username, value, _, notify in teachers
            )
        file.write(
            f"–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {count_users}\n\n"
            f"–°—Ç—É–¥–µ–Ω—Ç—ã (–≤—Å–µ–≥–æ: {len(students)}):\n{students_list}\n\n"
            f"–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–∏ (–≤—Å–µ–≥–æ: {len(teachers)}):\n{teachers_list}")

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª
    file_from_pc = FSInputFile("users_list.txt")
    await message.answer_document(file_from_pc, caption="–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")

    # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
    os.remove("users_list.txt")

async def send_users_paginated(message: types.Message, users: list, page: int = 0):
    users_per_page = 20
    start = page * users_per_page
    end = start + users_per_page
    users_slice = users[start:end]

    response = "–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n\n"
    for user in users_slice:
        user_id, username, value, is_teacher, notify = user
        role = "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å" if is_teacher else "–°—Ç—É–¥–µ–Ω—Ç"
        response += f"|üÜî: {user_id}| |üë§: @{username}| |–†–æ–ª—å: {role}| |–ì—Ä—É–ø–ø–∞\–§–ò–û: {value}| |üîî: {notify}|\n"

    # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
    keyboard_buttons = []
    if page > 0:
        keyboard_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"users_page_{page - 1}"))
    keyboard_buttons.append(InlineKeyboardButton(text="üè†", callback_data="main_menu"))
    if end < len(users):
        keyboard_buttons.append(InlineKeyboardButton(text="–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è", callback_data=f"users_page_{page + 1}"))

    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏
    keyboard = InlineKeyboardMarkup(inline_keyboard=[keyboard_buttons])

    await message.answer(response, reply_markup=keyboard)

async def send_schedule(message: types.Message, days_offset: int, caption: str, send_as_text: bool = False):
    target_date = (date.today() + timedelta(days=days_offset)).strftime("%d.%m.%Y")
    file_name = f'schedule/{target_date}.docx'
    user_id = message.from_user.id
    value, is_teacher, _ = get_user_data(user_id)
    username = message.from_user.username
    if value is None or is_teacher is None:
        if send_as_text:
            await message.answer("–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Ñ–æ—Ä–º–µ, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å, –ø—Ä–æ–ø–∏—Å–∞–≤ /login.")
            logging.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} —Å–¥–µ–ª–∞–ª –∑–∞–ø—Ä–æ—Å, –±—É–¥—É—á–∏ –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º")
        else:
            if os.path.isfile(file_name):
                file_from_pc = FSInputFile(file_name)
                await message.answer_document(file_from_pc, caption=caption, reply_markup=main_keyboard)
            else:
                await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø–æ–∫–∞ –µ—â–µ –Ω–µ—Ç, –∏–∑–≤–∏–Ω–∏—Ç–µ", reply_markup=main_keyboard)
        return  # –ó–∞–≤–µ—Ä—à–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏

    try:
        if send_as_text:
            schedule_data, teacher_schedule_data = process_schedule_file(file_name)
            if schedule_data and teacher_schedule_data:
                if is_teacher:
                    if value in teacher_schedule_data:
                        all_entries = []
                        for group, entries in teacher_schedule_data[value].items():
                            for entry in entries.split('\n'):
                                pair_number = int(entry.split('|')[1].split('.')[0])
                                all_entries.append((pair_number, group, entry))

                        all_entries.sort(key=lambda x: x[0])

                        grouped_entries = []
                        current_group = None
                        current_entries = []
                        for pair_number, group, entry in all_entries:
                            if group == current_group:
                                current_entries.append(entry)
                            else:
                                if current_group:
                                    grouped_entries.append((current_group, current_entries))
                                current_group = group
                                current_entries = [entry]
                        if current_group:
                            grouped_entries.append((current_group, current_entries))

                        response = f"–í–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {target_date}:\n\n|–ü–∞—Ä–∞| |–ö–∞–±–∏–Ω–µ—Ç|\n\n"
                        for group, entries in grouped_entries:
                            response += f"–° –≥—Ä—É–ø–ø–æ–π {group}:\n"
                            response += '\n'.join(entries) + '\n\n'

                        await message.answer(response)
                    else:
                        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø–∞—Ä –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å.")
                else:
                    if value in schedule_data:
                        await message.answer(
                            f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {value} –Ω–∞ {target_date}:\n\n|–ü–∞—Ä–∞| |–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å| |–ö–∞–±–∏–Ω–µ—Ç|\n\n{schedule_data[value]}")
                    else:
                        await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            else:
                await message.answer("–ò–∑–≤–∏–Ω–∏—Ç–µ, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å.")
        else:
            if os.path.isfile(file_name):
                file_from_pc = FSInputFile(file_name)
                await message.answer_document(file_from_pc, caption=caption, reply_markup=main_keyboard)
            else:
                await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø–æ–∫–∞ –µ—â–µ –Ω–µ—Ç, –∏–∑–≤–∏–Ω–∏—Ç–µ", reply_markup=main_keyboard)

    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ —Ñ–∞–π–ª–∞: {e}")

async def send_schedule_choose_group(message: types.Message, group_name: str, days_offset: int, caption: str, send_as_text: bool = False):
    target_date = (date.today() + timedelta(days=days_offset)).strftime("%d.%m.%Y")
    file_name = f'schedule/{target_date}.docx'
    username = message.from_user.username
    value, is_teacher, _ = get_user_data(message.from_user.id)
    try:
        if value is None or is_teacher is None:
            if send_as_text:
                schedule_data, teacher_schedule_data = process_schedule_file(file_name)
                if schedule_data and teacher_schedule_data:
                    if group_name in schedule_data:
                        await message.answer(f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name} –Ω–∞ {target_date}:\n\n{schedule_data[group_name]}")
                        logging.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} —Å–¥–µ–ª–∞–ª –∑–∞–ø—Ä–æ—Å, –±—É–¥—É—á–∏ –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º")
                    else:
                        await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
                else:
                    await message.answer("–ò–∑–≤–∏–Ω–∏—Ç–µ, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å.")
            else:
                if os.path.isfile(file_name):
                    file_from_pc = FSInputFile(file_name)
                    await message.answer_document(file_from_pc, caption=caption, reply_markup=main_keyboard)
                else:
                    await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø–æ–∫–∞ –µ—â–µ –Ω–µ—Ç, –∏–∑–≤–∏–Ω–∏—Ç–µ", reply_markup=main_keyboard)
            return
        if send_as_text:
            schedule_data, teacher_schedule_data = process_schedule_file(file_name)
            if schedule_data and teacher_schedule_data:
                if group_name in schedule_data:
                    await message.answer(
                    f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name} –Ω–∞ {target_date}:\n\n{schedule_data[group_name]}")
                    await offer_to_add_favorite_group(message, group_name)
                else:
                    await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            else:
                await message.answer("–ò–∑–≤–∏–Ω–∏—Ç–µ, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å.")
        else:
            if os.path.isfile(file_name):
                file_from_pc = FSInputFile(file_name)
                await message.answer_document(file_from_pc, caption=caption, reply_markup=main_keyboard)
            else:
                await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø–æ–∫–∞ –µ—â–µ –Ω–µ—Ç, –∏–∑–≤–∏–Ω–∏—Ç–µ", reply_markup=main_keyboard)

    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ —Ñ–∞–π–ª–∞: {e}")

async def offer_to_add_favorite_group(message: types.Message, group_name: str):
    user_id = message.from_user.id
    favorite_groups = get_favorite_groups(user_id)

    if group_name in favorite_groups:
        # –ì—Ä—É–ø–ø–∞ —É–∂–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö, –Ω–∏—á–µ–≥–æ –Ω–µ –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º
        return

    # –°–æ–∑–¥–∞–µ–º inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ "–î–∞" –∏ "–ù–µ—Ç"
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–î–∞", callback_data=f"add_favorite_{group_name}")],
        [InlineKeyboardButton(text="–ù–µ—Ç", callback_data="cancel_favorite")]
    ])

    await message.answer(f"–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –≥—Ä—É–ø–ø—É {group_name} –≤ –∏–∑–±—Ä–∞–Ω–Ω—ã–µ?", reply_markup=keyboard)

async def send_as_text2(message: types.Message, file_name):
    target_date = message.text
    user_id = message.from_user.id
    username = message.from_user.username
    schedule_data, teacher_schedule_data = process_schedule_file(file_name)
    if schedule_data and teacher_schedule_data:
        value, is_teacher, _ = get_user_data(user_id)

        if value is None or is_teacher is None:
            await message.answer("–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Ñ–æ—Ä–º–µ, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å, –Ω–∞–ø–∏—Å–∞–≤ /login.")
            logging.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} —Å–¥–µ–ª–∞–ª –∑–∞–ø—Ä–æ—Å, –±—É–¥—É—á–∏ –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º")
            return

        if is_teacher:
            if value in teacher_schedule_data:
                all_entries = []
                for group, entries in teacher_schedule_data[value].items():
                    for entry in entries.split('\n'):
                        pair_number = int(entry.split('|')[1].split('.')[0])
                        all_entries.append((pair_number, group, entry))

                all_entries.sort(key=lambda x: x[0])

                grouped_entries = []
                current_group = None
                current_entries = []
                for pair_number, group, entry in all_entries:
                    if group == current_group:
                        current_entries.append(entry)
                    else:
                        if current_group:
                            grouped_entries.append((current_group, current_entries))
                        current_group = group
                        current_entries = [entry]
                if current_group:
                    grouped_entries.append((current_group, current_entries))

                response = f"–í–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {target_date}:\n\n |–ü–∞—Ä–∞| |–ö–∞–±–∏–Ω–µ—Ç|\n\n"
                for group, entries in grouped_entries:
                    response += f"–° –≥—Ä—É–ø–ø–æ–π {group}:\n"
                    response += '\n'.join(entries) + '\n\n'

                await message.answer(response)
            else:
                await message.answer("–°—É–¥—è –ø–æ —Ñ–∞–π–ª—É, —É –≤–∞—Å –Ω–µ—Ç –ø–∞—Ä –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞.")
        else:
            if value in schedule_data:
                await message.answer(
                    f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {value} –Ω–∞ {target_date}:\n\n|–ü–∞—Ä–∞| |–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å| |–ö–∞–±–∏–Ω–µ—Ç|\n\n{schedule_data[value]}")
            else:
                await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
    else:
        await message.answer("–ò–∑–≤–∏–Ω–∏—Ç–µ, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å.")

async def send_as_text_for_another_group(message: types.Message, file_name, group_name):
    target_date = message.text
    user_id = message.from_user.id
    username = message.from_user.username
    schedule_data, teacher_schedule_data = process_schedule_file(file_name)
    value = group_name
    if schedule_data and teacher_schedule_data:
        _ , is_teacher, _ = get_user_data(user_id)

        if value is None or is_teacher is None:
            await message.answer("–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Ñ–æ—Ä–º–µ, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å, –Ω–∞–ø–∏—Å–∞–≤ /login.")
            logging.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} —Å–¥–µ–ª–∞–ª –∑–∞–ø—Ä–æ—Å, –±—É–¥—É—á–∏ –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º")
            return

        if is_teacher:
            if value in teacher_schedule_data:
                all_entries = []
                for group, entries in teacher_schedule_data[value].items():
                    for entry in entries.split('\n'):
                        pair_number = int(entry.split('|')[1].split('.')[0])
                        all_entries.append((pair_number, group, entry))

                all_entries.sort(key=lambda x: x[0])

                grouped_entries = []
                current_group = None
                current_entries = []
                for pair_number, group, entry in all_entries:
                    if group == current_group:
                        current_entries.append(entry)
                    else:
                        if current_group:
                            grouped_entries.append((current_group, current_entries))
                        current_group = group
                        current_entries = [entry]
                if current_group:
                    grouped_entries.append((current_group, current_entries))

                response = f"–í–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {target_date}:\n\n |–ü–∞—Ä–∞| |–ö–∞–±–∏–Ω–µ—Ç|\n\n"
                for group, entries in grouped_entries:
                    response += f"–° –≥—Ä—É–ø–ø–æ–π {group}:\n"
                    response += '\n'.join(entries) + '\n\n'

                await message.answer(response)
            else:
                await message.answer("–°—É–¥—è –ø–æ —Ñ–∞–π–ª—É, —É –≤–∞—Å –Ω–µ—Ç –ø–∞—Ä –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞.")
        else:
            if value in schedule_data:
                await message.answer(
                    f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {value} –Ω–∞ {target_date}:\n\n|–ü–∞—Ä–∞| |–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å| |–ö–∞–±–∏–Ω–µ—Ç|\n\n{schedule_data[value]}")
            else:
                await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
    else:
        await message.answer("–ò–∑–≤–∏–Ω–∏—Ç–µ, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å.")

async def send_notification(chat_id, message):
    await bot.send_message(chat_id, message)


async def download_other_date(date: str):
    target_date = date
    filename = f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ {target_date}.docx"
    root_directory = "/–î–¢–ö/–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞–Ω—è—Ç–∏–π/"

    def find_file_sync(yadisk, directory, filename):
        for item in yadisk.listdir(directory):
            if item['type'] == 'dir':
                found_file = find_file_sync(yadisk, item['path'], filename)
                if found_file:
                    return found_file
            elif item['name'] == filename:
                return item['path']
        return None

    def download_file_sync(file_path, local_path):
        yadisk_client.download(file_path, local_path)

    try:
        file_path = await asyncio.to_thread(find_file_sync, yadisk_client, root_directory, filename)
        if file_path:
            local_path = f"schedule/{target_date}.docx"
            await asyncio.to_thread(download_file_sync, file_path, local_path)
            logging.info(f"–§–∞–π–ª –Ω–∞ {target_date} —Å–∫–∞—á–µ–Ω –∏–∑ {file_path}")
            return True  # –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω
        else:
            logging.warning(f"–§–∞–π–ª–∞ –Ω–∞ {target_date} –Ω–µ—Ç")
            return False  # –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞ –Ω–∞ {target_date}: {e}")
        return False  # –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞


async def download_schedule(days_offset: int):
    target_date = (date.today() + timedelta(days=days_offset)).strftime("%d.%m.%Y")
    filename = f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ {target_date}.docx"
    root_directory = "/–î–¢–ö/–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞–Ω—è—Ç–∏–π/"
    local_path = f"schedule/{target_date}.docx"

    def find_file_sync(yadisk, directory, filename):
        for item in yadisk.listdir(directory):
            if item['type'] == 'dir':
                found_file = find_file_sync(yadisk, item['path'], filename)
                if found_file:
                    return found_file
            elif item['name'] == filename:
                return item['path']
        return None

    def download_file_sync(file_path, local_path):
        yadisk_client.download(file_path, local_path)

    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ö–µ—à (–µ—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
    old_hash = None
    if os.path.exists(local_path):
        old_hash = get_file_hash(local_path)

    try:
        file_path = await asyncio.to_thread(find_file_sync, yadisk_client, root_directory, filename)
        if file_path:
            local_path = f"schedule/{target_date}.docx"
            await asyncio.to_thread(download_file_sync, file_path, local_path)
            new_hash = get_file_hash(local_path)
            if old_hash and new_hash != old_hash:
                logging.info(f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {target_date} –∏–∑–º–µ–Ω–∏–ª–æ—Å—å –∏ –±—ã–ª–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä")
                # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –∫–µ—à, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
                cache_key = f"{target_date}.docx"
                if cache_key in schedule_cache:
                    del schedule_cache[cache_key]
                    logging.info(f"–ö–µ—à –¥–ª—è {target_date} –æ—á–∏—â–µ–Ω –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º")
                await check_and_notify(filename, update=True)
            elif not old_hash:
                logging.info(f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {target_date} –∑–∞–≥—Ä—É–∂–µ–Ω–æ")
                check_and_notify(filename)
        else:
            logging.warning(f"–§–∞–π–ª–∞ –Ω–∞ {target_date} –Ω–µ—Ç")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞ –Ω–∞ {target_date}: {e}")


async def send_schedule_to_all_users(days_offset: int, caption: str):
    users = get_all_users_data()
    if not users:
        logging.warning("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è.")
        return

    target_date = (date.today() + timedelta(days=days_offset)).strftime("%d.%m.%Y")
    file_name = f'schedule/{target_date}.docx'

    if not os.path.isfile(file_name):
        logging.warning(f"–§–∞–π–ª —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–∞ {target_date} –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–µ—à–∞ (–±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—ë–Ω –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
    cache_result = process_schedule_file(file_name)
    if not cache_result:
        return

    schedule_data, teacher_schedule_data = cache_result["data"]
    day_text = "–Ω–∞ —Å–µ–≥–æ–¥–Ω—è" if days_offset == 0 else "–Ω–∞ –∑–∞–≤—Ç—Ä–∞"

    for user_id, username, value, is_teacher, notifications_enabled in users:
        if notifications_enabled == 1:
            try:
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª —Å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º
                file_from_pc = FSInputFile(file_name)
                await bot.send_document(user_id, file_from_pc, caption=caption)

                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞
                schedule_data, teacher_schedule_data = process_schedule_file(file_name)
                if is_teacher:
                    if value in teacher_schedule_data:
                        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è
                        all_entries = []
                        for group, entries in teacher_schedule_data[value].items():
                            for entry in entries.split("\n"):
                                pair_number = entry.split("|")[1].split(".")[0].strip()  # –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–æ–º–µ—Ä –ø–∞—Ä—ã
                                all_entries.append((int(pair_number), group, entry))

                        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –≤—Å–µ –ø–∞—Ä—ã –ø–æ –Ω–æ–º–µ—Ä—É
                        all_entries.sort(key=lambda x: x[0])

                        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ–¥—Ä—è–¥ –∏–¥—É—â–∏–µ –ø–∞—Ä—ã –¥–ª—è –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã, –µ—Å–ª–∏ –æ–Ω–∏ –∏–¥—É—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
                        grouped_entries = []
                        current_group = None
                        current_entries = []
                        for pair_number, group, entry in all_entries:
                            if group == current_group:
                                # –ï—Å–ª–∏ –≥—Ä—É–ø–ø–∞ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–π, –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –≤ —Ç–µ–∫—É—â–∏–π –±–ª–æ–∫
                                current_entries.append(entry)
                            else:
                                # –ï—Å–ª–∏ –≥—Ä—É–ø–ø–∞ –¥—Ä—É–≥–∞—è, —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –±–ª–æ–∫
                                if current_group:
                                    grouped_entries.append((current_group, current_entries))
                                current_group = group
                                current_entries = [entry]
                        if current_group:
                            grouped_entries.append((current_group, current_entries))

                    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—ã–π –æ—Ç–≤–µ—Ç
                        response = f"–í–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ {day_text}:\n\n |–ü–∞—Ä–∞| |–ö–∞–±–∏–Ω–µ—Ç|\n\n"
                        for group, entries in grouped_entries:
                            response += f"–° –≥—Ä—É–ø–ø–æ–π {group}:\n"
                            response += "\n".join(entries) + "\n\n"

                        await bot.send_message(user_id, response)
                    else:
                        await bot.send_message(user_id, "–í–æ–∑–º–æ–∂–Ω–æ —É –≤–∞—Å –Ω–µ—Ç –ø–∞—Ä –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
                else:
                    if value in schedule_data:
                        await bot.send_message(user_id,
                                           f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {value} {day_text}:\n\n{schedule_data[value]}")
                    else:
                        await bot.send_message(user_id, "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            except Exception as e:
                logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
        else:
            continue

async def favorite_groups_show(message: types.Message, cancle: bool = False):
    user_id = message.from_user.id
    keyboard = create_favorite_groups_keyboard(user_id)
    if not cancle:
        sent_message = await message.answer(
            "–ó–∞–≥—Ä—É–∂–∞—é –∏–∑–±—Ä–∞–Ω–Ω—ã–µ –≥—Ä—É–ø–ø—ã...",
            reply_markup=ReplyKeyboardRemove()
        )
        await asyncio.sleep(3)
        await bot.delete_message(chat_id=message.chat.id, message_id=sent_message.message_id)
    # –ó–∞—Ç–µ–º —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º –≠–¢–û –ñ–ï —Å–æ–æ–±—â–µ–Ω–∏–µ, –¥–æ–±–∞–≤–ª—è—è inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    await message.answer(
        "–í–∞—à–∏ –∏–∑–±—Ä–∞–Ω–Ω—ã–µ –≥—Ä—É–ø–ø—ã:",
        reply_markup=keyboard
    )
    del user_states["profile_edit"][user_id]

async def morning_schedule_task():
    await send_schedule_to_all_users(days_offset=0, caption="–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è")


async def evening_schedule_task():
    await send_schedule_to_all_users(days_offset=1, caption="–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞")
